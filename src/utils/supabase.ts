import { createClient } from '@supabase/supabase-js';

// Your Supabase project credentials
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Database Types
export interface WatchPartyRoom {
  id: string;
  room_code: string;
  host_name: string;
  created_at: string;
  expires_at: string;
  is_active: boolean;
  current_media?: {
    type: 'movie' | 'tv';
    id: number;
    title: string;
    season?: number;
    episode?: number;
    server_url?: string;
  };
playback_state?: {
    is_playing: boolean;
    current_time: number;
    last_updated: string;
    updated_by: string;
  };
}

export interface WatchPartyMember {
  id: string;
  room_id: string;
  name: string;
  is_host: boolean;
  joined_at: string;
  last_seen: string;
  is_online: boolean;
}

export interface WatchPartyEvent {
  id: string;
  room_id: string;
  event_type: 'play' | 'pause' | 'seek' | 'episode_change' | 'member_join' | 'member_leave' | 'room_created';
  event_data: any;
  triggered_by: string;
  created_at?: string;  // Auto-generated by database
  timestamp: string;    // For backward compatibility
}

// API Functions
export const watchPartyApi = {
  // Create a new watch party room
  async createRoom(hostName: string, mediaData?: any): Promise<{ room: WatchPartyRoom; member: WatchPartyMember }> {
    const response = await fetch(`${supabaseUrl}/functions/v1/create-watch-party`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${supabaseAnonKey}`,
      },
      body: JSON.stringify({ hostName, mediaData }),
    });

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Failed to create room');
    }

    return { room: data.room, member: data.member };
  },

  // Join an existing watch party room
  async joinRoom(roomCode: string, memberName: string): Promise<{ room: WatchPartyRoom; member: WatchPartyMember }> {
    const response = await fetch(`${supabaseUrl}/functions/v1/join-watch-party`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${supabaseAnonKey}`,
      },
      body: JSON.stringify({ roomCode, memberName }),
    });

    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Failed to join room');
    }

    return { room: data.room, member: data.member };
  },

  // Sync playback state
  async syncPlayback(roomId: string, eventType: string, eventData: any, triggeredBy: string): Promise<void> {
    console.log('Attempting to sync playback via direct database insert...');
    
    try {
      // Insert event directly into watch_party_events table (without created_at - it's auto-generated)
      const { error } = await supabase
        .from('watch_party_events')
        .insert({
          room_id: roomId,
          event_type: eventType,
          event_data: eventData,
          triggered_by: triggeredBy
        });

      if (error) {
        console.error('Direct database sync error:', error);
        throw new Error(error.message);
      }

      console.log('Direct database sync successful');

      // Also update the room's playback state if it's a playback-related event
      if (eventType === 'play' || eventType === 'pause' || eventType === 'seek') {
        const playbackUpdate = {
          is_playing: eventType === 'play',
          current_time: eventData?.currentTime || 0,
          last_updated: new Date().toISOString(),
          updated_by: triggeredBy
        };

        console.log('Updating room playback state:', playbackUpdate);

        const { error: updateError } = await supabase
          .from('watch_party_rooms')
          .update({
            playback_state: playbackUpdate
          })
          .eq('id', roomId);

        if (updateError) {
          console.error('Failed to update room playback state:', updateError);
        } else {
          console.log('Room playback state updated successfully');
        }
      }

    } catch (directError) {
      console.log('Direct database approach failed, trying Edge Function...');
      
      // Fallback to Edge Function
      const response = await fetch(`${supabaseUrl}/functions/v1/sync-playback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${supabaseAnonKey}`,
        },
        body: JSON.stringify({ roomId, eventType, eventData, triggeredBy }),
      });

      const data = await response.json();
      
      if (!response.ok || !data.success) {
        throw new Error(data.error || `HTTP ${response.status}: Failed to sync playback`);
      }
    }
  },

  // Leave room
  async leaveRoom(_roomId: string, memberId: string): Promise<void> {
    const { error } = await supabase
      .from('watch_party_members')
      .update({ is_online: false })
      .eq('id', memberId);

    if (error) throw error;
  },

  // Get room details
  async getRoomDetails(roomId: string): Promise<WatchPartyRoom | null> {
    const { data, error } = await supabase
      .from('watch_party_rooms')
      .select('*')
      .eq('id', roomId)
      .eq('is_active', true)
      .single();

    if (error) return null;
    return data;
  },

  // Get room members
  async getRoomMembers(roomId: string): Promise<WatchPartyMember[]> {
    const { data, error } = await supabase
      .from('watch_party_members')
      .select('*')
      .eq('room_id', roomId)
      .eq('is_online', true)
      .order('joined_at', { ascending: true });

    if (error) return [];
    return data || [];
  }
};
